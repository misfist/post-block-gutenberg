{"version":3,"sources":["@wordpress/rich-text/src/to-dom.js"],"names":["TEXT_NODE","window","Node","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","createEmpty","document","append","element","child","ownerDocument","createTextNode","type","attributes","createElement","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","getText","nodeValue","remove","removeChild","toDom","value","multilineTag","prepareEditableTree","isEditableTree","startPath","endPath","formats","tree","onStartIndex","body","pointer","onEndIndex","selection","apply","current","__unstableDomOnly","applyValue","start","undefined","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","nodeName","data","replaceChild","currentAttributes","futureAttributes","ii","name","getAttribute","removeAttribute","isRangeEqual","a","b","startContainer","startOffset","endContainer","endOffset","getSelection","range","createRange","setStart","setEnd","activeElement","focus","rangeCount","getRangeAt","removeAllRanges","addRange"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\n/**\n * Returns a new instance of a DOM tree upon which RichText operations can be\n * applied.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createEmpty`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @return {WPRichTextTree} RichText tree.\n */\nconst createEmpty = () => createElement( document, '' );\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tprepareEditableTree,\n\tisEditableTree = true,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\t\t},\n\t\tisEditableTree,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      $1                        Named arguments.\n * @param {Object}      $1.value                  Value to apply.\n * @param {HTMLElement} $1.current                The live root node to apply the element tree to.\n * @param {string}      [$1.multilineTag]         Multiline tag.\n * @param {Array}       [$1.multilineWrapperTags] Tags where lines can be found if nesting is possible.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tprepareEditableTree,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === TEXT_NODE && currentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range} a First range object to test.\n * @param {Range} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual( a, b ) {\n\treturn (\n\t\ta.startContainer === b.startContainer &&\n\t\ta.startOffset === b.startOffset &&\n\t\ta.endContainer === b.endContainer &&\n\t\ta.endOffset === b.endOffset\n\t);\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, endPath );\n\tconst selection = window.getSelection();\n\tconst { ownerDocument } = current;\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\t// Set back focus if focus is lost.\n\tif ( ownerDocument.activeElement !== current ) {\n\t\tcurrent.focus();\n\t}\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n}\n"]}